;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                     FEVEREIRO DE 2023                           *
;*                 BASEADO NO EXEMPLO DO LIVRO                     *
;*           Desbravando o PIC. David José de Souza                *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 16f628A                                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              UNIVERSIDADE FEDERAL DA PARAÍBA			   *
;*		ENGENHARIA DE COMPUTAÇÃO			   *
;*								   *
;*			MICROCONTROLADORES			   *
;*								   *
;*			 ROSIVALDO LUCAS			   *
;*-----------------------------------------------------------------*
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675
;
;	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

; PIC16F628A Configuration Bit Settings

; Assembly source line config statements

#INCLUDE "p16f628a.inc" ;ARQUIVO PADRÃO MICROCHIP PARA 16F628A

; CONFIG
; __config 0xFFF8
 __CONFIG _FOSC_INTOSCIO & _WDTE_OFF & _PWRTE_OFF & _MCLRE_ON & _BOREN_ON & _LVP_ON & _CPD_OFF & _CP_OFF
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES

		;COLOQUE AQUI SUAS NOVAS VARIÁVEIS
		;NÃO ESQUEÇA COMENTÁRIOS ESCLARECEDORES
		CONTA_0_5_SEGUNDOS

	ENDC			;FIM DO BLOCO DE DEFINIÇÃO DE VARIÁVEIS

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP			;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP		;COPIA STATUS PARA STATUS_TEMP

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÃO ESCRITAS AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

;FUNÇÃO QUE TEM COMO OBJETIVO DEIXAR A PORTA RB0 EM NIVEL LÓGICO BAIXO SEMPRE QUE A PORTA RA0 ESTIVER EM NIVEL LÓGICO ALTO
;PROTEÇÃO DO PROGRAMA
BAIXO_RB0
	BCF	    PORTB,RB0		;SETA O BIT RB0 PARA NÍVEL LÓGICO BAIXO
	
	REPETE
	BTFSS	    PORTB,RB0		;VERIFICA SE O BIT RB0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN				;SE O BIT RA0 FOR ZERO, RETORNA PARA A EXECUÇÃO DAS NOTAS
	GOTO	    REPETE		;SE O BIT RA0 FOR UM, REPETE E FICA EM LOOP ATÉ O BIT RA0 FOR IGUAL A ZERO (INDICANDO QUE PODE REPRODUZIR AS NOTAS)

;DEFINE O DELAY DAS NOTAS
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA DÓ
DELAY_NOTA_DO
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .17			    ;MOVE O VALOR 17 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 17 PARA O TIMER0
	
	REPETE_DELAY_NOTA_DO
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_DO    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL DÓ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA RÉ
DELAY_NOTA_RE
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .43			    ;MOVE O VALOR 43 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 43 PARA O TIMER0
	
	REPETE_DELAY_NOTA_RE
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_RE    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL RÉ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA MI
DELAY_NOTA_MI
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .66			    ;MOVE O VALOR 66 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 66 PARA O TIMER0
	
	REPETE_DELAY_NOTA_MI
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_MI    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL MI

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA FÁ
DELAY_NOTA_FA
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .77			    ;MOVE O VALOR 77 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 77 PARA O TIMER0
	
	REPETE_DELAY_NOTA_FA
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_FA    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL FÁ

;FUNÇAO DE DELAY PARA O SINAL DA NOTA SOL
DELAY_NOTA_SOL
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .96			    ;MOVE O VALOR 96 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 96 PARA O TIMER0
	
	REPETE_DELAY_NOTA_SOL
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PR?XIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_SOL   ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL SOL
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA LÁ
DELAY_NOTA_LA
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .114		    ;MOVE O VALOR 114 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 114 PARA O TIMER0
	
	REPETE_DELAY_NOTA_LA
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_LA    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL LÁ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA SI
DELAY_NOTA_SI
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .129		    ;MOVE O VALOR 129 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 129 PARA O TIMER0
	
	REPETE_DELAY_NOTA_SI
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_SI    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL SI

;DEFINE OS SINAIS DAS NOTAS

;VALORES PARA A VARIÁVEL CONTA_0_5_SEGUNDOS FORAM OBTIDOS EXPERIMENTALMENTE REALIZANDO TESTES E VERIFICANDO
;NO STOPWATCH SE A EXECUÇÃO DE CADA NOTA TINHA DURAÇÃO PRÓXIMA DE 0.5 SEGUNDOS
	
NOTA_DO
	MOVLW	    .130
	MOVWF	    CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_DO
	BTFSC	    PORTA,RA0
	RETURN
	
	BSF	    PORTB,RB0
	CALL	    DELAY_NOTA_DO
	BCF	    PORTB,RB0
	CALL	    DELAY_NOTA_DO
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F
	GOTO	    REPETE_NOTA_DO
	RETURN

;EXECUTA O SINAL DA NOTA RÉ
NOTA_RE
	MOVLW	    .148		    ;MOVE O VALOR 148 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_RE
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_RE	    ;CHAMA DELAY DO SINAL R?
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_RE	    ;CHAMA DELAY DO SINAL R?
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_RE	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA MI
NOTA_MI
	MOVLW	    .164		    ;MOVE O VALOR 164 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_MI
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_MI	    ;CHAMA DELAY DO SINAL MI
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_MI	    ;CHAMA DELAY DO SINAL MI
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_MI	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS

;EXECUTA O SINAL DA NOTA F?
NOTA_FA
	MOVLW	    .173		    ;MOVE O VALOR 173 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_FA
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_FA	    ;CHAMA DELAY DO SINAL F?
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_FA	    ;CHAMA DELAY DO SINAL F?
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_FA	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA SOL
NOTA_SOL
	MOVLW	    .195		    ;MOVE O VALOR 195 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_SOL
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_SOL	    ;CHAMA DELAY DO SINAL SOL
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_SOL	    ;CHAMA DELAY DO SINAL SOL
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_SOL	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA L?
NOTA_LA
	MOVLW	    .220		    ;MOVE O VALOR 220 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_LA
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_LA	    ;CHAMA DELAY DO SINAL L?
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_LA	    ;CHAMA DELAY DO SINAL L?
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_LA	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS

;EXECUTA O SINAL DA NOTA SI
NOTA_SI
	MOVLW	    .245		    ;MOVE O VALOR 245 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_SI
	BTFSC	    PORTA,RA0		    ;VERIFICA SE O BIT GP0 ? IGUAL A UM, SE FOR, EXECUTA A PR?XIMA LINHA, SE N?O, PULA A PR?XIMA LINHA
	RETURN
	
	BSF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO ALTO
	CALL	    DELAY_NOTA_SI	    ;CHAMA DELAY DO SINAL SI
	BCF	    PORTB,RB0		    ;SETA O BIT GP5 PARA N?VEL L?GICO BAIXO
	CALL	    DELAY_NOTA_SI	    ;CHAMA DELAY DO SINAL SI
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARI?VEL, SE FOR ZERO, SAI DA FUN??O, J? PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_SI	    ;REPETE A CONTAGEM, N?O SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, J? SE PASSOU 0.5 SEGUNDOS
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00000001'		;CONFIGURA A PORTA RA0 COMO ENTRADA
	MOVWF	TRISA			;COMO SAÍDAS/ENTRADAS
	
	MOVLW	B'00000000'		;CONFIGURA A PORTA RB0 COMO SAÍDA
	MOVWF	TRISB			
	
	MOVLW	B'00000010'		;PRESCALER DE 1:8 TMR0 INCREMENTA A CADA 8 CICLOS DE MÁQUINA
	MOVWF	OPTION_REG		;DEFINE OPÇÕES DE OPERAÇÃO
	
	MOVLW	B'00000000'
	MOVWF	INTCON			;DEFINE OPÇÕES DE INTERRUPÇÕES
	
	BANK0				;RETORNA PARA O BANCO
	MOVLW	B'00000111'		;DESABILITA OS COMPARADORES INTERNOS
	MOVWF	CMCON			;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MAIN

	;CORPO DA ROTINA PRINCIPAL

	;O SINAL DAS NOTAS É GERADO PELA PORTA RB0 E TEM DURAÇÃO APROXIMADAMENTE 0.5 SEGUNDOS
	;COM DUTY CYCLE DE 50%
	;ENQUANTO RA0 ESTIVER EM NÍVEL LÓGICO BAIXO, A SEQUÊNCIA DE NOTAS É EXECUTADA
	;SE A PORTA RA0 ESTIVER EM NÍVEL LÓGICO ALTO, A SEQUÊNCIA DE NOTAS É PAUSADA E A PORTA RB0 É SETADA COM NÍVEL LÓGICO BAIXO
	
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_DO	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA DÓ
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	CALL	    NOTA_RE	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA RÉ
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_MI	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA MI
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_FA	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA FÁ
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_SOL	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA SOL
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_LA	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA LÁ
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	BTFSS	    PORTA,RA0	    ;VERIFICA SE O BIT RA0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_SI	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA SI
	CALL	    BAIXO_RB0	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT RB0 EM NÍVEL LÓGICO BAIXO
	
	GOTO	    MAIN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END
