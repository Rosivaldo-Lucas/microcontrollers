;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                     FEVEREIRO DE 2023                           *
;*                 BASEADO NO EXEMPLO DO LIVRO                     *
;*           Desbravando o PIC. David José de Souza                *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              UNIVERSIDADE FEDERAL DA PARAÍBA			   *
;*		    ENGENHARIA DE COMPUTAÇÃO			   *
;*								   *
;*		        MICROCONTROLADORES			   *
;*								   *
;*			  ROSIVALDO LUCAS			   *
;*-----------------------------------------------------------------*
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES

		CONTA_0_5_SEGUNDOS	;VARIÁVEL QUE IRÁ CONTAR 0.5 SEGUNDOS DE DURAÇÃO PARA CADA SINAL DAS NOTAS
		
		;COLOQUE AQUI SUAS NOVAS VARIÁVEIS
		;NÃO ESQUEÇA COMENTÁRIOS ESCLARECEDORES

	ENDC			;FIM DO BLOCO DE DEFINIÇÃO DE VARIÁVEIS

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÃO ESCRITAS AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.


;FUNÇÃO QUE TEM COMO OBJETIVO DEIXAR A PORTA GP5 EM NÍVEL LÓGICO BAIXO SEMPRE QUE A PORTA GP0 ESTIVER EM NÍVEL LÓGICO ALTO
BAIXO_GP5
	BCF	    GPIO,GP5	    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	
	REPETEE
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN			    ;SE O BIT GP0 FOR ZERO, RETORNA PARA A EXECUÇÃO DAS NOTAS
	GOTO	    REPETEE	    ;SE O BIT GP0 FOR UM, REPETE E FICA EM LOOP ATÉ O BIT GP0 FOR IGUAL A ZERO

;DEFINE O DELAY DAS NOTAS
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA DÓ
DELAY_NOTA_DO
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .17			    ;MOVE O VALOR 17 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 17 PARA O TIMER0
	
	REPETE_DELAY_NOTA_DO
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_DO    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL DÓ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA RÉ
DELAY_NOTA_RE
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .43			    ;MOVE O VALOR 43 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 43 PARA O TIMER0
	
	REPETE_DELAY_NOTA_RE
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_RE    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL RÉ
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA MI
DELAY_NOTA_MI
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .66			    ;MOVE O VALOR 66 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 66 PARA O TIMER0
	
	REPETE_DELAY_NOTA_MI
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_MI    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL MI
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA FÁ
DELAY_NOTA_FA
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .77			    ;MOVE O VALOR 77 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 77 PARA O TIMER0
	
	REPETE_DELAY_NOTA_FA
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_FA    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL FÁ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA SOL
DELAY_NOTA_SOL
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .96			    ;MOVE O VALOR 96 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 96 PARA O TIMER0
	
	REPETE_DELAY_NOTA_SOL
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_SOL   ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL SOL
	
;FUNÇÃO DE DELAY PARA O SINAL DA NOTA LÁ
DELAY_NOTA_LA
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .114		    ;MOVE O VALOR 114 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 114 PARA O TIMER0
	
	REPETE_DELAY_NOTA_LA
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_LA    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL LÁ

;FUNÇÃO DE DELAY PARA O SINAL DA NOTA SI
DELAY_NOTA_SI
	BCF	    INTCON,T0IF		    ;SETA PARA ZERO O BIT T0IF DO REGISTRADOR INTCON
	MOVLW	    .129		    ;MOVE O VALOR 129 PARA O WORK
	MOVWF	    TMR0		    ;MOVE O VALOR 129 PARA O TIMER0
	
	REPETE_DELAY_NOTA_SI
	BTFSS	    INTCON,T0IF		    ;VERIFICA SE O BIT T0IF É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	GOTO	    REPETE_DELAY_NOTA_SI    ;O BIT T0IF É ZERO, ENTÃO NÃO TERMINOU DE CONTAR, REPETE O PROCESSO
	RETURN				    ;FINALIZA O DELAY DO SINAL SI

;DEFINE OS SINAIS DAS NOTAS

;VALORES PARA A VARIÁVEL CONTA_0_5_SEGUNDOS FORAM OBTIDOS EXPERIMENTALMENTE. REALIZANDO TESTES E VERIFICANDO
;NO STOPWATCH SE A EXECUÇÃO DE CADA NOTA TINHA DURAÇÃO PRÓXIMA DE 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA DÓ
NOTA_DO
	MOVLW	    .130		    ;MOVE O VALOR 130 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_DO
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_DO	    ;CHAMA DELAY DO SINAL DÓ
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_DO	    ;CHAMA DELAY DO SINAL DÓ
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_DO	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS

;EXECUTA O SINAL DA NOTA RÉ
NOTA_RE
	MOVLW	    .148		    ;MOVE O VALOR 148 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_RE
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_RE	    ;CHAMA DELAY DO SINAL RÉ
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_RE	    ;CHAMA DELAY DO SINAL RÉ
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_RE	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS

;EXECUTA O SINAL DA NOTA MI
NOTA_MI
	MOVLW	    .164		    ;MOVE O VALOR 164 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_MI
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_MI	    ;CHAMA DELAY DO SINAL MI
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_MI	    ;CHAMA DELAY DO SINAL MI
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_MI	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA FÁ
NOTA_FA
	MOVLW	    .173		    ;MOVE O VALOR 173 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_FA
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_FA	    ;CHAMA DELAY DO SINAL FÁ
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_FA	    ;CHAMA DELAY DO SINAL FÁ
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_FA	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA SOL
NOTA_SOL
	MOVLW	    .195		    ;MOVE O VALOR 195 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_SOL
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_SOL	    ;CHAMA DELAY DO SINAL SOL
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_SOL	    ;CHAMA DELAY DO SINAL SOL
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_SOL	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS
	
;EXECUTA O SINAL DA NOTA LÁ
NOTA_LA
	MOVLW	    .220		    ;MOVE O VALOR 220 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_LA
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_LA	    ;CHAMA DELAY DO SINAL LÁ
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_LA	    ;CHAMA DELAY DO SINAL LÁ
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_LA	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS

;EXECUTA O SINAL DA NOTA SI
NOTA_SI
	MOVLW	    .245		    ;MOVE O VALOR 245 PARA O WORK
	MOVWF	    CONTA_0_5_SEGUNDOS	    ;MOVE O VALOR DE WORK PARA CONTA_0_5_SEGUNDOS
	
	REPETE_NOTA_SI
	BTFSC	    GPIO,GP0		    ;VERIFICA SE O BIT GP0 É IGUAL A UM, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	RETURN
	
	BSF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO ALTO
	CALL	    DELAY_NOTA_SI	    ;CHAMA DELAY DO SINAL SI
	BCF	    GPIO,GP5		    ;SETA O BIT GP5 PARA NÍVEL LÓGICO BAIXO
	CALL	    DELAY_NOTA_SI	    ;CHAMA DELAY DO SINAL SI
	
	DECFSZ	    CONTA_0_5_SEGUNDOS,F    ;DECREMENTA E ARMAZENA O VALOR NA VARIÁVEL, SE FOR ZERO, SAI DA FUNÇÃO, JÁ PASSOU 0.5 SEGUNDOS
	GOTO	    REPETE_NOTA_SI	    ;REPETE A CONTAGEM, NÃO SE PASSOU 0.5 SEGUNDOS
	RETURN				    ;RETORNA, JÁ SE PASSOU 0.5 SEGUNDOS

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1			    ;ALTERA PARA O BANCO 1
	MOVLW	B'00001001'	    ;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		    ;COMO SAÍDAS
	CLRF	ANSEL		    ;DEFINE PORTAS COMO Digital I/O
	MOVLW	B'00000010'
	MOVWF	OPTION_REG	    ;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'00000000'
	MOVWF	INTCON		    ;DEFINE OPÇÕES DE INTERRUPÇÕES
	BANK0			    ;RETORNA PARA O BANCO
	MOVLW	B'00000111'
	MOVWF	CMCON		    ;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MAIN

	;CORPO DA ROTINA PRINCIPAL

	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_DO	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA DÓ
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	CALL	    NOTA_RE	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA RÉ
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_MI	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA MI
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_FA	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA FÁ
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_SOL	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA SOL
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_LA	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA LÁ
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	BTFSS	    GPIO,GP0	    ;VERIFICA SE O BIT GP0 É IGUAL A ZERO, SE FOR, EXECUTA A PRÓXIMA LINHA, SE NÃO, PULA A PRÓXIMA LINHA
	CALL	    NOTA_SI	    ;CHAMA A FUNÇÃO QUE EXECUTA A NOTA SI
	CALL	    BAIXO_GP5	    ;CHAMA A FUNÇÃO QUE DEIXA O BIT GP5 EM NÍVEL LÓGICO BAIXO
	
	GOTO	MAIN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END
